/**
 * @file Firebase Security Rules for CampusMind App
 * @core_philosophy This ruleset enforces a strict user-ownership model for personal data,
 *  role-based access for administrative functions, and public read access for shared resources.
 * @data_structure The data is organized hierarchically.
 *   - User accounts and profiles are stored separately under `/userAccounts/{userId}` and `/userProfiles/{userProfileId}`.
 *   - User-specific data (conversations, appointments) is nested under `/users/{userId}`.
 *   - Public resources are stored in the top-level `/resources` collection.
 *   - Anonymous forum posts are stored in the `/posts` collection.
 *   - Analytics data is stored in the `/analytics` collection.
 * @key_security_decisions
 *   - Users can only access their own user account and profile data.
 *   - Users can only access their own conversations and appointments.
 *   - Public resources are readable by all authenticated users.
 *   - Only administrators can read analytics data.
 *   - Listing of all users is disallowed.
 *   - Conversations with counselors and scheduling of appointments
 *     also provide access to counselors.
 * @denormalization_for_authorization User roles are denormalized into the `userAccounts`
 *  document to avoid costly `get()` calls in security rules.
 * @structural_segregation Private user data is stored under user-specific paths,
 *  while public resources are stored in a top-level collection to enable secure list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @returns {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided userId.
     * @param {string} userId - The user ID to compare against.
     * @returns {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an existing owner of the document.
     * @param {string} userId - The user ID to compare against.
     * @returns {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user has the 'admin' role.
     * @returns {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/userAccounts/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * @description Checks if the authenticated user has the 'counselor' role.
     * @returns {boolean} True if the user is a counselor, false otherwise.
     */
    function isCounselor() {
      return isSignedIn() && get(/databases/$(database)/documents/userAccounts/$(request.auth.uid)).data.role == 'counselor';
    }

    /**
     * @description Rules for user account documents.
     * @path /userAccounts/{userAccountId}
     * @allow (create) User with ID 'user123' can create their account.
     *   request.auth.uid = 'user123'
     *   request.resource.data.id = 'user123'
     * @allow (get) User with ID 'user123' can get their account.
     *   request.auth.uid = 'user123'
     * @deny (create) User with ID 'user456' cannot create an account for 'user123'.
     *   request.auth.uid = 'user456'
     *   request.resource.data.id = 'user123'
     * @principle Enforces document ownership and prevents unauthorized account creation.
     */
    match /userAccounts/{userAccountId} {
      allow get: if isOwner(userAccountId);
      allow list: if false; // Listing all user accounts is not permitted.
      allow create: if isOwner(userAccountId) && request.resource.data.id == userAccountId;
      allow update: if isExistingOwner(userAccountId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userAccountId);
    }

    /**
     * @description Rules for user profile documents.
     * @path /userProfiles/{userProfileId}
     * @allow (create) User with ID 'user123' can create their profile.
     *   request.auth.uid = 'user123'
     *   request.resource.data.id = 'user123'
     * @allow (get) User with ID 'user123' can get their profile.
     *   request.auth.uid = 'user123'
     * @deny (create) User with ID 'user456' cannot create a profile for 'user123'.
     *   request.auth.uid = 'user456'
     *   request.resource.data.id = 'user123'
     * @principle Enforces document ownership and prevents unauthorized profile creation.
     */
    match /userProfiles/{userProfileId} {
      allow get: if isSignedIn();
      allow list: if false; // Listing all user profiles is not permitted.
      allow create: if isSignedIn() && request.resource.data.id == userProfileId;
      allow update: if isSignedIn() && request.resource.data.id == resource.data.id;
      allow delete: if false; // User profiles should not be deleted directly, only through account deletion.
    }

    /**
     * @description Rules for conversations within a user's data.
     * @path /users/{userId}/conversations/{conversationId}
     * @allow (create) User 'user123' can create a conversation.
     *   request.auth.uid = 'user123'
     * @allow (get) User 'user123' can get their conversation.
     *   request.auth.uid = 'user123'
     * @deny (create) User 'user456' cannot create a conversation for user 'user123'.
     *   request.auth.uid = 'user456'
     * @principle Restricts access to a user's own conversations.
     */
    match /users/{userId}/conversations/{conversationId} {
      allow get: if isOwner(userId) || isCounselor();
      allow list: if isOwner(userId) || isCounselor();
      allow create: if isOwner(userId) || isCounselor();
      allow update: if isExistingOwner(userId) || isCounselor();
      allow delete: if isExistingOwner(userId) || isCounselor();
    }

    /**
     * @description Rules for appointments within a user's data.
     * @path /users/{userId}/appointments/{appointmentId}
     * @allow (create) User 'user123' can create an appointment.
     *   request.auth.uid = 'user123'
     * @allow (get) User 'user123' can get their appointment.
     *   request.auth.uid = 'user123'
     * @deny (create) User 'user456' cannot create an appointment for user 'user123'.
     *   request.auth.uid = 'user456'
     * @principle Restricts access to a user's own appointments.
     */
    match /users/{userId}/appointments/{appointmentId} {
      allow get: if isOwner(userId) || isCounselor();
      allow list: if isOwner(userId) || isCounselor();
      allow create: if isOwner(userId) || isCounselor();
      allow update: if isExistingOwner(userId) || isCounselor();
      allow delete: if isExistingOwner(userId) || isCounselor();
    }

    /**
     * @description Rules for counselor profiles.
     * @path /counselors/{counselorId}
     * @allow (get) Any authenticated user can view counselor profiles.
     *   request.auth != null
     * @deny (create) Only admins can create counselor profiles.
     *   request.auth.uid != adminUserId
     * @principle Allows public read access to counselor profiles, restricts write access to admins.
     */
    match /counselors/{counselorId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for mental health resources.
     * @path /resources/{resourceId}
     * @allow (get) Any authenticated user can access resources.
     *   request.auth != null
     * @deny (create) Only admins can create resources.
     *   request.auth.uid != adminUserId
     * @principle Allows public read access to resources for authenticated users.
     */
    match /resources/{resourceId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for anonymous forum posts.
     * @path /posts/{postId}
     * @allow (get) Any authenticated user can view posts.
     *   request.auth != null
     * @deny (create) Only authenticated users can create posts.
     *   request.auth == null
     * @principle Allows authenticated users to read and create posts, but restricts modification to moderators.
     */
    match /posts/{postId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if false; // Posts can't be updated
      allow delete: if false; // Posts can't be deleted
    }

    /**
     * @description Rules for analytics data.
     * @path /analytics/{date}
     * @allow (get) Only admins can access analytics.
     *   request.auth.uid = adminUserId
     * @deny (create) Only admins can create analytics.
     *   request.auth.uid != adminUserId
     * @principle Restricts access to analytics data to administrators only.
     */
    match /analytics/{date} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}